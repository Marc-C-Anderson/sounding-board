<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            color: white;
            font-family: sans-serif;
        }

        canvas {
            border: 1px solid #444;
            cursor: crosshair;
            background: #000;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
        }
    </style>
</head>

<body>
    <nav>
        <a href="index.html">Index</a>
    </nav>
    <div class="controls">Click and drag to hammer the string!</div>
    <canvas id="stringCanvas"></canvas>

    <script>
        const canvas = document.getElementById('stringCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        canvas.width = 800;
        canvas.height = 400;
        const N = 100; // Number of points
        const dx = canvas.width / (N - 1);
        const dt = 0.1;
        const c = 2.0; // Wave speed
        const damping = 0.995; // Energy loss

        // State Arrays
        let u = new Float32Array(N);     // Current displacement
        let u_prev = new Float32Array(N); // Previous displacement
        let u_next = new Float32Array(N); // Next displacement

        // Interaction state
        let isPlucking = false;

        function update() {
            if (!isPlucking) {
                // Apply Wave Equation: u_next = 2u - u_prev + (c*dt/dx)^2 * (u_right - 2u + u_left)
                const tension = Math.pow((c * dt) / 1, 2);

                for (let i = 1; i < N - 1; i++) {
                    u_next[i] = 2 * u[i] - u_prev[i] + tension * (u[i + 1] - 2 * u[i] + u[i - 1]);
                    u_next[i] *= damping; // Apply friction
                }

                // Swap buffers
                u_prev.set(u);
                u.set(u_next);
            }
            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.strokeStyle = '#00ffcc';
            ctx.lineWidth = 2;

            const centerY = canvas.height / 2;

            for (let i = 0; i < N; i++) {
                const x = i * dx;
                const y = centerY + u[i];
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // Interaction Logic
        // canvas.addEventListener('mousedown', () => isPlucking = true);
        // window.addEventListener('mouseup', () => isPlucking = false);
        // canvas.addEventListener('mousemove', (e) => {
        //     if (isPlucking) {
        //         const rect = canvas.getBoundingClientRect();
        //         const mouseX = e.clientX - rect.left;
        //         const mouseY = e.clientY - rect.top - (canvas.height / 2);

        //         const peakIndex = Math.floor(mouseX / dx);

        //         for (let i = 0; i < N; i++) {
        //             if (i <= peakIndex) {
        //                 // Linear ramp from left wall (0) to mouse
        //                 u[i] = (i / peakIndex) * mouseY;
        //             } else {
        //                 // Linear ramp from mouse to right wall (N-1)
        //                 u[i] = (1 - (i - peakIndex) / (N - 1 - peakIndex)) * mouseY;
        //             }
        //         }

        //         // Sync u_prev so the string starts from "rest" at this new shape
        //         u_prev.set(u);
        //     }
        // });

        // Example: Hammer at 1/4th of the string when clicking
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            hammerOn(mouseX, 20); // Positive 20 "pushes" the string down
        });

        function hammerOn(positionX, force) {
            const centerIndex = Math.floor(positionX / dx);
            const width = 5; // How many points the hammer hits

            for (let i = -width; i <= width; i++) {
                const index = centerIndex + i;
                if (index > 0 && index < N - 1) {
                    // Calculate a bell-curve (Gaussian) for the impact area
                    const impact = Math.exp(-(i * i) / (width * 0.5));
                    // Add to the current displacement based on force
                    u[index] += force * impact;
                }
            }
            // We do NOT set u_prev = u here. 
            // The difference between u and u_prev is what creates the kinetic energy.
        }
        update();
    </script>
</body>

</html>